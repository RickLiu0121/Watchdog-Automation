"""
JIRA URL: https://ford.atlassian.net/browse/NETNTEST-574

    This a program that utilizes Watchdog 4 API to generate two Excels, "All_test_results_without_defects.xlsx" and
"Latest_tests_without_defects.xlsx".

    In "All_test_results_without_defects.xlsx", Test Results view is used to give a list of all failed or blocked test
results without defects on Testrail. A pivot table is automatically generated by this program. Note: the case id can
occur in multiple entries because each test run assigns a different ID to the Testrail test case.

    In "Latest_tests_without_defects.xlsx", Test Case view is used to capture the latest results for all the
existing test cases on Watchdog. Then a filter will also get a list of all failed and blocked test cases without any
defects. A pivot table is automatically generated by this program. Note: On Watchdog, the total number of test cases
won't change even when different "test result status" filter" are applied. For example, if "Test result status" only
have "Blocked" and "Failed" checked but not "Passed", then Test Case view only give the latest Blocked and Failed
results for all test cases, EVEN IF THE TEST CASE HAVE A MORE RECENT PASS RESULT". This Excel generated by the program
needs to be further tested and verified. Manually download csv from Watchdog, create pivot table and compare with the
"Latest_tests_without_defects.xlsx"

    Currently, the program uses the same Watchdog 4 filterId URLs for both Test Result and Test Case view because the
same filterId applies to both views.

    Ideally this program should be automated and ran daily

Useful Watchdog 4 filterId URLs:
https://wdog.ford.com/testing/test-results?filterId=772
https://wdog.ford.com/testing/test-results?filterId=1021

https://wdog.ford.com/testing/test-results?filterId=1018 (Test Case view with only Blocked and Failed)

"""

import json
import os
import logging
import keyring
import openpyxl
from openpyxl.utils import get_column_letter
import pandas as pd
from watchdog4_interface.api import WatchdogAPI
import win32com.client as win32
from datetime import timedelta, date
from dateutil.parser import parse
import time

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s", )


def create_watchdog_session_get_test_results(filter_id: int, is_latest: bool):
    """
    Call watchdog API and get test results/cases data
    Example watchdog URL with filterId: https://wdog.ford.com/testing/test-results?filterId=772
    (the same filterId also applies to Test Case view)

    Filter out data given the time frame we'd like to track
    (this should probably break into another function)
    """
    watchdog_api = WatchdogAPI("https://wdog.ford.com/api")
    credential = keyring.get_credential("watchdog4", "")
    password = keyring.get_password("watchdog4", str(credential))
    watchdog_api.create_session(credential, password)
    logging.info(f"Pulling data from watchdog for filterid: {filter_id}")
    if is_latest:
        test_results = watchdog_api.test_cases_for_filter(filter_id)
        filter_id_list = []
        """Get test results on and before a particular date (default: date.today())"""
        for test_result in test_results.values():
            temp_date = test_result.get("tested_on", None)
            if temp_date is not None:
                temp_date = parse(temp_date[0:10]).date()
                if date.today() >= temp_date:
                    filter_id_list.append(test_result.get("case_id"))
            else:
                filter_id_list.append(test_result.get("case_id"))
    else:
        test_results = watchdog_api.test_results_for_filter(filter_id)
        today = True
        """Get test results within 10 days from a particular today (default:date.today())"""
        if today:
            today_date = date.today()
            filter_id_list = [test_result.get("result_src_id") for test_result in test_results.values()
                              if (today_date - parse(test_result["result_created_on"][0:10]).date() <= timedelta(
                                days=10))]
        else:
            example_date = date(2023, 12, 7)
            filter_id_list = [test_result.get("result_src_id") for test_result in test_results.values()
                              if (example_date - parse(test_result["result_created_on"][0:10]).date() <= timedelta(
                                days=10))
                              and (example_date - parse(test_result["result_created_on"][0:10]).date() >= timedelta(
                                days=1))]

    """
    Below is the logic to create json data files (currently only keeps the data from the last WD4 filterId ran)
    This will increase running time it's currently commented out
    Ideally this block of code should be placed in a different file and create 4 json files in a sub directory
    """
    json_file = f"test_results_with_filterId{filter_id}.json"
    content = json.dumps(test_results, indent=4)
    if not os.path.exists(os.path.join(os.getcwd(), json_file)):
        create_test_results_json(json_file, content)
        logging.info(f"Created json data file for filterid: {filter_id}")
    else:
        create_test_results_json(json_file, content)
        logging.info(f"Updated json data file for filterid: {filter_id}")
    test_results = {key: value for key, value in test_results.items() if key in filter_id_list}
    return test_results


def create_test_results_json(name: str, content: str):
    """
    Create json data files to verify data collection
    :param name:
    :param content:
    :return:
    """
    with open(name, mode="w") as f:
        f.write(content)


def create_output_xlsx(excel_name: str, sheet_names: list):
    """
    Create Excel document in the same directory with the specific sheets already in it
    :param excel_name:
    :param sheet_names:
    :return:
    """
    if os.path.exists(os.path.join(os.getcwd(), excel_name)):
        return False
    wb = openpyxl.Workbook()
    """Rename the first sheet"""
    wb_sheet = wb["Sheet"]
    wb_sheet.title = sheet_names[0]
    """Add more sheets"""
    for i in range(1, len(sheet_names)):
        wb.create_sheet(sheet_names[i])
    wb.save(excel_name)
    return True


def write_header_only(excel_name: str, sheet_names):
    """
    The header fields are different for test_cases_for_filter() and test_results_for_filter()
    Executing this function will ERASE everything in the existing Excel

    These header strictly match the API response from WD4 so if Watchdog dev push any updates we also need
    change ours accordingly
    """

    if "All" in excel_name:
        header = pd.DataFrame(
            columns=["result_id", "result_src_id", "result_source", "test_result_status", "result_created_by",
                     "result_created_on", "test_environment", "case_id", "case_title", "test_case_type",
                     "derived_milestone",
                     "result_milestone", "child_milestone", "test_case_status", "project", "priority", "frequency",
                     "automation", "created_on", "created_by", "updated_on", "suite", "refs", "test_quadrant", "tags",
                     "architectures", "components", "defects_csv", "defects"]
        )
    else:
        header = pd.DataFrame(
            columns=["case_id", "source", "title", "refs", "project", "test_case_type", "test_case_status", "priority",
                     "frequency", "automation", "components", "tags", "architectures", "created_on", "created_by",
                     "updated_on", "updated_by", "suite", "test_quadrant", "result_id", "result_status", "tested_by",
                     "tested_on", "test_environment", "run_name", "plan_name", "milestone", "parent_milestone",
                     "defects_csv", "defects"]
        )

    with pd.ExcelWriter(excel_name) as writer:
        for i in range(len(sheet_names)):
            header.to_excel(writer, index=False, header=True, sheet_name=sheet_names[i])


def filter_no_defect_tests_id(test_results: dict, test_status_filter_words: list, sheet_name: str, file_path):
    count = 0
    filtered_id_list = []
    if "All" in file_path:
        test_result_str = "test_result_status"
        entry_id = "result_src_id"
    else:
        test_result_str = "result_status"
        entry_id = "case_id"
    for _test_result in test_results.values():
        if (_test_result.get(test_result_str) in test_status_filter_words and (_test_result.get("defects") is None)
                and (_test_result.get("defects_csv") is None)):
            filtered_id_list.append(_test_result.get(entry_id))
            count += 1
    return filtered_id_list, count


def add_to_excel(file_path: str, sheet_name: str, test_results: dict, test_status_filter_words, index):
    """
    Do a further filtering process to get all blocked and Failed test results/cases without defects
    Add these entries to Excel
    :param file_path:
    :param sheet_name:
    :param test_results:
    :param test_status_filter_words: "Blocked", "Failed"
    :param index:
    :return:
    """
    logging.info(f"Updating Excel for {sheet_name}")
    filter_id_list, num = filter_no_defect_tests_id(test_results, test_status_filter_words, sheet_name, file_path)
    with pd.ExcelWriter(file_path, mode='a', if_sheet_exists="overlay") as writer:
        for i in range(num):
            filtered_test_result = test_results.get(filter_id_list[i])
            df = pd.DataFrame([list(filtered_test_result.values())])
            df.to_excel(writer, index=False, header=False, startrow=i + 1, sheet_name=sheet_name)
    set_column_width(file_path, sheet_name)

    """
    If no data added to the sheet then no need to create pivot table for that sheet
    (A good thing because all blocked and failed have defects attached) 
    """
    if filter_id_list:
        output_file_path = os.path.join(os.getcwd(), file_path)
        create_pivot_table(output_file_path, index, sheet_name)


def set_column_width(file_path, sheet_name):
    """
    A neat way to set columns width
    :param file_path:
    :param sheet_name:
    :return:
    """
    column_widths = [15] * 27
    wb = openpyxl.load_workbook(filename=file_path)
    sheet = wb[sheet_name]
    for i, column_width in enumerate(column_widths, 1):  # to start at 1
        sheet.column_dimensions[get_column_letter(i)].width = column_width
    wb.save(filename=file_path)


def create_pivot_table(file_path, index, sheet_name):
    """
    Create pivot table on a per-sheet basis for an Excel
    :param file_path: path of Excel document created
    :param index: the sheet index
    :param sheet_name: name of the sheet
    :return:
    """
    try:
        excel = win32.GetActiveObject("Excel.Application")
        logging.info("Running Excel instance found, returning object")
        if excel:
            raise Exception("Please save or close your opened Excel Files before executing this program")
    except Exception:
        pass
    wb = openpyxl.load_workbook(filename=file_path)
    if "Report" not in wb.sheetnames:
        wb.create_sheet("Report", 0)
    wb.save(file_path)
    xl_app = win32.Dispatch("Excel.Application")  # Always seems to launch Excel interface
    xl_app.Visible = False  # this variable doesn't seem to do anything
    position = ["B3", "B12"]  # specify location of the pivot table
    wb = xl_app.Workbooks.Open(file_path)
    ws_data = wb.Worksheets(sheet_name)
    ws_report = wb.Worksheets("Report")

    # Create data cache for the sheet selected
    pivot_table_cache = wb.PivotCaches().Create(1, ws_data.Range("A1").CurrentRegion)
    pt = pivot_table_cache.CreatePivotTable(ws_report.Range(position[index]), f"{sheet_name} Pivot Table")

    # Set pivot tables properties
    pt.ColumnGrand = True
    pt.RowGrand = True
    pt.SubtotalLocation(2)
    pt.RowAxisLayout(1)
    pt.TableStyle2 = "PivotStyleMedium9"

    # use built-in method to get data from Excel sheet
    field_rows = {"project": pt.PivotFields("suite")}
    field_values = {"count": pt.PivotFields("case_id")}

    if "All" in file_path:
        field_columns = {"test_result_status": pt.PivotFields("test_result_status")}
    else:
        field_columns = {"test_result_status": pt.PivotFields("result_status")}

    # Assign Pivot table category just like how you would create a pivot table
    field_rows["project"].Orientation = 1
    field_columns["test_result_status"].Orientation = 2
    field_values["count"].Orientation = 4
    field_values["count"].Function = -4112
    ws = wb.Worksheets("Report")
    ws.Range("B:B").ColumnWidth = 30

    wb.Save()
    xl_app.Quit()  # Exit Excel interface
    time.sleep(5)  # Give enough time for Excel to close


def main():
    """
    Execute the program
    """
    output_file_names = {"All_test_results_without_defects.xlsx": False, "Latest_tests_without_defects.xlsx": True}
    # output_file_names = {"Latest_tests_without_defects.xlsx": True}
    for output_file_name, is_latest in output_file_names.items():
        test_status_filter_words = ["Blocked", "Failed"]

        # Use these two filter ids in case other data analytics are needed
        sheet_dict = {"Network Node": 772, "Rigil Shared Services": 1021}
        if create_output_xlsx(output_file_name, list(sheet_dict.keys())):
            logging.info(f"Successfully created output file:{output_file_name}")
        else:
            logging.info(f"Output file:{output_file_name} already created")

        """Also clears existing data"""
        write_header_only(output_file_name, list(sheet_dict.keys()))

        for i, (sheet_name, watchdog_filter_id) in enumerate(sheet_dict.items()):
            # Right now the implementation of passing <test_results> is not ideal
            # because it is slow and inefficient due to the large amount of data from Watchdog

            # It would be better to pass pointers or generators increase speed of the program

            test_results = create_watchdog_session_get_test_results(watchdog_filter_id, is_latest)
            add_to_excel(sheet_name=sheet_name, test_status_filter_words=test_status_filter_words,
                         test_results=test_results, file_path=output_file_name, index=i)


if __name__ == "__main__":
    main()
    logging.info("Successful")
